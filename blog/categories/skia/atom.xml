<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Skia | lvpengwei’s Blog]]></title>
  <link href="http://lvpengwei.github.io//blog/categories/skia/atom.xml" rel="self"/>
  <link href="http://lvpengwei.github.io//"/>
  <updated>2023-04-13T23:21:15+08:00</updated>
  <id>http://lvpengwei.github.io//</id>
  <author>
    <name><![CDATA[lvpengwei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[纹理边缘抗锯齿 CoverageAA]]></title>
    <link href="http://lvpengwei.github.io//blog/2021/12/11/wen-li-bian-yuan-kang-ju-chi-coverage-aa/"/>
    <updated>2021-12-11T12:30:34+08:00</updated>
    <id>http://lvpengwei.github.io//blog/2021/12/11/wen-li-bian-yuan-kang-ju-chi-coverage-aa</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>用 OpenGL 旋转图片的时候，图片边缘会出现锯齿。</p>

<p>图 1 是没有做抗锯齿的时候，可以明显看到边缘的锯齿。</p>

<div align=center>
<img src="https://s2.loli.net/2021/12/11/QsFLYTfqxGlEWBv.png" width="500"/>
<br/>
图 1
</div>


<h2>思路</h2>

<p>首先想到的是 OpenGL 提供的 MSAA，但是 MSAA 占用内存比较多。然后去查了下 skia 的抗锯齿是如何实现的，发现它只是对图片边缘的 1px 做一个 alpha 从 1->0 渐变的遮罩。</p>

<p>如图 2 所示，矩形 abcd 是我们要绘制的区域，根据矩形的坐标向内缩 0.5px 得到矩形 P0_P1_P3_P2，向外扩 0.5px 得到矩形 P4_P5_P7_P6。内矩形里面 alpha 都是 1，外矩形边缘 alpha 都是 0，内矩形和外矩形之间 alpha 从 1->0 渐变。这样我们就对边缘做了一个逐渐消失的效果，从视觉上看，边缘的锯齿就没那么明显了。</p>

<div align=center>
<img src="https://s2.loli.net/2021/12/05/KtvNZQPdw8SLHTq.png" width="500"/>
<br/>
图 2
</div>


<h2>解决</h2>

<h3>没有抗锯齿</h3>

<p>在没有使用抗锯齿时，我们绘制一个矩形，提交的是 cdba 4 个顶点，2 个三角形。
<code>cpp
auto bounds = args.rectToDraw;  
auto normalBounds = Rect::MakeLTRB(0, 0, 1, 1);
return {  
  bounds.right, bounds.bottom, normalBounds.right, normalBounds.bottom,  
  bounds.right, bounds.top, normalBounds.right, normalBounds.top,  
  bounds.left, bounds.bottom, normalBounds.left, normalBounds.bottom,  
  bounds.left, bounds.top, normalBounds.left, normalBounds.top,  
};
</code>
对应的绘制命令是
<code>cpp
gl-&gt;drawArrays(GL_TRIANGLE_STRIP, 0, 4);
</code></p>

<h3>抗锯齿 CoverageAA</h3>

<p>在使用 CoverageAA 抗锯齿时，我们绘制一个矩形，提交的是内矩形 P0P1P2P3 和外矩形 P4P5P6P7 的 8 个顶点：
```cpp
auto bounds = args.rectToDraw;
auto normalBounds = Rect::MakeLTRB(0, 0, 1, 1);</p>

<p>auto padding = 0.5f;<br/>
auto insetBounds = bounds.makeInset(padding, padding);<br/>
auto outsetBounds = bounds.makeOutset(padding, padding);</p>

<p>auto normalPadding = Point::Make(padding / bounds.width(), padding / bounds.height());<br/>
auto normalInset = normalBounds.makeInset(normalPadding.x, normalPadding.y);<br/>
auto normalOutset = normalBounds.makeOutset(normalPadding.x, normalPadding.y);
return {<br/>
  insetBounds.left, insetBounds.top, 1.0f, normalInset.left, normalInset.top,<br/>
  insetBounds.left, insetBounds.bottom, 1.0f, normalInset.left, normalInset.bottom,<br/>
  insetBounds.right, insetBounds.top, 1.0f, normalInset.right, normalInset.top,<br/>
  insetBounds.right, insetBounds.bottom, 1.0f, normalInset.right, normalInset.bottom,<br/>
  outsetBounds.left, outsetBounds.top, 0.0f, normalOutset.left, normalOutset.top,<br/>
  outsetBounds.left, outsetBounds.bottom, 0.0f, normalOutset.left, normalOutset.bottom,<br/>
  outsetBounds.right, outsetBounds.top, 0.0f, normalOutset.right, normalOutset.top,<br/>
  outsetBounds.right, outsetBounds.bottom, 0.0f, normalOutset.right, normalOutset.bottom,<br/>
};
<code>
转换成三角形是 30 个顶点，下面是三角形的 index 数据
</code>cpp
static constexpr int kIndicesPerAAFillRect = 30;
static constexpr uint16_t gFillAARectIdx[] = {<br/>
  0, 1, 2, 1, 3, 2,<br/>
  0, 4, 1, 4, 5, 1,<br/>
  0, 6, 4, 0, 2, 6,<br/>
  2, 3, 6, 3, 7, 6,<br/>
  1, 5, 3, 3, 5, 7,<br/>
};
<code>
绘制命令是
</code>cpp
glDrawElements(GL_TRIANGLES, kIndicesPerAAFillRect, GL_UNSIGNED_SHORT, 0);
```</p>

<h2>结果</h2>

<p>图 3 是做完抗锯齿的效果，可以看到边缘的锯齿已经没有了。</p>

<div align=center>
<img src="https://s2.loli.net/2021/12/11/gquEYZ2hc1JM57H.png" width="500"/>
<br/>
图 3
</div>


<p>图 4 是图 1 和 图 3 边缘对比的细节，可以看到边缘像素的过渡圆滑了很多。</p>

<div align=center>
<img src="https://s2.loli.net/2021/12/11/hHuSMsJ8zZbvrVo.png" width="500"/>
<br/>
图 4
</div>


<h2>链接</h2>

<p><a href="https://github.com/google/skia">skia</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS NV12转SkImage颜色不正常的问题]]></title>
    <link href="http://lvpengwei.github.io//blog/2020/03/07/ios-nv12zhuan-skimageyan-se-bu-zheng-chang-de-wen-ti/"/>
    <updated>2020-03-07T11:01:32+08:00</updated>
    <id>http://lvpengwei.github.io//blog/2020/03/07/ios-nv12zhuan-skimageyan-se-bu-zheng-chang-de-wen-ti</id>
    <content type="html"><![CDATA[<h1>环境</h1>

<p>设备：iPhone 6s<br/>
系统：13.1<br/>
Skia版本：m62<br/>
视频的YUV ColorSpace：ITU-R BT.601</p>

<h1>现象</h1>

<p>VideoToolbox 配置的 pixelFormat 是<code>kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange</code>，然后把输出的 pixelBuffer 用下面的代码片段1转成 NV12，再使用代码片段2转成 SkImage，在 SkCanvas 上 draw 出来如图1，视频原图如图2。</p>

<pre><code class="objc">uint32_t pixelFormatType = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange;
</code></pre>

<pre><code class="objc">// 代码片段1
// Y 数据
CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,
                                             textCache,
                                             pixelBuffer,
                                             NULL,
                                             GL_TEXTURE_2D,
                                             GL_LUMINANCE,
                                             width,
                                             height,
                                             GL_LUMINANCE,
                                             GL_UNSIGNED_BYTE,
                                             0,
                                             &amp;outputTextureLuma);
// UV 数据
CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,
                                             textCache,
                                             pixelBuffer,
                                             NULL,
                                             GL_TEXTURE_2D,
                                             GL_LUMINANCE_ALPHA,
                                             width / 2,
                                             height / 2,
                                             GL_LUMINANCE_ALPHA,
                                             GL_UNSIGNED_BYTE,
                                             1,
                                             &amp;outputTextureChroma);
</code></pre>

<pre><code class="cpp">// 代码片段2
GrGLTextureInfo textureInfo1 = {videoImage-&gt;textureTarget(), videoImage-&gt;getTextureID(0)};
GrGLTextureInfo textureInfo2 = {videoImage-&gt;textureTarget(), videoImage-&gt;getTextureID(1)};
GrBackendObject nv12TextureHandles[] = {reinterpret_cast&lt;GrBackendObject&gt;(&amp;textureInfo1),
                                        reinterpret_cast&lt;GrBackendObject&gt;(&amp;textureInfo2)};
SkISize nv12Sizes[] = \{\{videoImage-&gt;width(), videoImage-&gt;height()\},
                       \{videoImage-&gt;width(), videoImage-&gt;height()\}\};
skImage = SkImage::MakeFromNV12TexturesCopy(grContext,
                                            kRec601_SkYUVColorSpace,
                                            nv12TextureHandles,
                                            nv12Sizes,
                                            kTopLeft_GrSurfaceOrigin,
                                            nullptr);
</code></pre>

<p><img src="/images/20200307/nv12_ra.png" alt="图1" />
<img src="/images/20200307/nv12_rg.png" alt="图2" /></p>

<h1>查问题</h1>

<h4>1. 查视频的 YUV ColorSpace 是否和 SkImage 对应</h4>

<p>是一致的，但输出的图像还是有问题。</p>

<h3>2.试试把 VideoToolbox 的输出格式换成 RGBA</h3>

<p>配置 VideoToolbox 的 pixelFormat 为 <code>kCVPixelFormatType_32BGRA</code>，使用代码片段3把 pixelBuffer 转成 RGBA 纹理，然后使用代码片段4转成 SkImage，图像是正常的。
<code>objc
uint32_t pixelFormatType = kCVPixelFormatType_32BGRA;
</code>
<code>objc
// 代码片段3
CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,
                                             textCache,
                                             pixelBuffer,
                                             NULL,
                                             GL_TEXTURE_2D,
                                             GL_RGBA,
                                             width,
                                             height,
                                             GL_BGRA,
                                             GL_UNSIGNED_BYTE,
                                             0,
                                             &amp;outputTextureLuma);
</code>
<code>cpp
// 代码片段4
GrGLTextureInfo textureInfo = {videoImage-&gt;textureTarget(), videoImage-&gt;getTextureID(0)};
GrBackendTexture backendTexture(videoImage-&gt;width(), videoImage-&gt;height(), kRGBA_8888_GrPixelConfig,
                                textureInfo);
skImage =  SkImage::MakeFromTexture(grContext, backendTexture, kTopLeft_GrSurfaceOrigin,
                                    kPremul_SkAlphaType, nullptr);
</code></p>

<h3>3.查 Skia 源码</h3>

<pre><code class="cpp">// SkImage_Gpu.cpp
// SkImage::MakeFromNV12TexturesCopy -&gt; make_from_yuv_textures_copy
// GrYUVEffect.cpp
// GrYUVEffect::MakeYUVToRGB -&gt; YUVtoRGBEffect::Make -&gt; YUVtoRGBEffect() -&gt; onCreateGLSLInstance() -&gt; GLSLProcessor -&gt; shader '.rg'
</code></pre>

<p>从 Skia 的源码中一直跟下去，发现最后 shader 使用的是 <code>rg</code> 通道，而因为我们是用 <code>GL_LUMINANCE_ALPHA</code> 来获取 <code>UV</code> 数据，在 GLSL 中应该使用 <code>ra</code> 通道，所以出现了不一致。当使用<code>GL_RG</code>获取<code>UV</code>数据的时候（代码片段5），SkImage 输出的图片就正常了。
<code>objc
// 代码片段5
// UV 数据
CVOpenGLESTextureCacheCreateTextureFromImage(kCFAllocatorDefault,
                                             textCache,
                                             pixelBuffer,
                                             NULL,
                                             GL_TEXTURE_2D,
                                             GL_RG,
                                             width / 2,
                                             height / 2,
                                             GL_RG,
                                             GL_UNSIGNED_BYTE,
                                             1,
                                             &amp;outputTextureChroma);
</code></p>

<h1>Link</h1>

<p><a href="https://github.com/google/skia">skia</a><br/>
<a href="https://juejin.im/entry/5cbac68c6fb9a0688c039ebc">GL 移植到 Metal 的小细节</a></p>
]]></content>
  </entry>
  
</feed>
