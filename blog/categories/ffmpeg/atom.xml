<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ffmpeg | lvpengwei’s Blog]]></title>
  <link href="http://lvpengwei.github.io//blog/categories/ffmpeg/atom.xml" rel="self"/>
  <link href="http://lvpengwei.github.io//"/>
  <updated>2023-04-13T23:21:15+08:00</updated>
  <id>http://lvpengwei.github.io//</id>
  <author>
    <name><![CDATA[lvpengwei]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mp3精准seek与比特池技术]]></title>
    <link href="http://lvpengwei.github.io//blog/2020/04/11/mp3jing-zhun-seekyu-bi-te-chi-ji-zhu/"/>
    <updated>2020-04-11T16:00:20+08:00</updated>
    <id>http://lvpengwei.github.io//blog/2020/04/11/mp3jing-zhun-seekyu-bi-te-chi-ji-zhu</id>
    <content type="html"><![CDATA[<blockquote><p>ffmpeg 的 seek flag AVSEEK_FLAG_ANY 并不精准。</p></blockquote>

<h3>起因</h3>

<p>最近在做音频剪辑的功能，有下面的场景</p>

<p>一段音频，一个时间区间将它分成三段，前段和后段速度保持不变，中间一段变速2倍。</p>

<p>实现上，我分成了三个不同的 segment 来处理，segment.start 不等于 0 的，会执行一下 seek，使用的是 ffmpeg 的 <code>AVSEEK_FLAG_ANY | AVSEEK_FLAG_BACKWARD</code>，来精准 seek，完成之后发现段与段交接的地方声音并不连贯。</p>

<h4>裁剪 frame</h4>

<p>我已经做了一个处理，在段结尾的时候，裁掉多余的bytes，在段开始的时候也裁掉，保证段与段之间解码后的数据连续。但是声音还是不连续。</p>

<pre><code class="cpp">std::shared_ptr&lt;SampleData&gt; AudioSegmentReader::copyNextSample() {  
    if (currentLength &gt;= endLength) {  
        return nullptr;  
    }  
    auto data = copyNextSampleInternal();  
    if (data == nullptr) {  
        return nullptr;  
    }  
    // 裁掉结尾多余的 bytes
    data-&gt;length = std::min(data-&gt;length, endLength -   currentLength);  
    currentLength += data-&gt;length;  
    return data;  
}

// 解码出的数据判断是否需要裁掉开头的 bytes
data = decoder-&gt;onRenderFrame();
auto time = decoder-&gt;currentPresentationTime();
if (0 &lt;= time &amp;&amp; time &lt; startTime) {
    auto delta = startLength - SampleTimeToLength(time, outputSetting.get());
    if (delta &lt; data-&gt;length) {
        data-&gt;data += delta;
        data-&gt;length -= delta;
    } else {
        data-&gt;data = nullptr;
        data-&gt;length = 0;
    }
}
</code></pre>

<h4>排查 packet 和 frame</h4>

<p>打印了一下段与段连接地方的 packet 的 packetData 和 frameData，发现 packetData 正常，seek 之后的 frameData 中前面大部分是 0，和上一段结尾解出的 frameData 不一样。记得音频帧可以独立解码，不需要参考前面的帧数据，那问题出现在哪里？</p>

<blockquote><p>一个测试：解封装连续，解码之前 flush 一下 decoder，会发现 frameData 基本都是有问题的。</p></blockquote>

<h4>了解 mp3 帧头格式</h4>

<p>很多规则，但是没卵用。</p>

<h4>比特池技术</h4>

<p>最后去查 mp3 的解码过程实现，发现 mp3 使用了比特池技术，当前帧的主数据可能放在上一帧。。。。也就是要实现精准 seek，得往前多 seek 几帧，然后把前面的 frame 丢掉。
试了一下，结果如预期。</p>

<h3>参考</h3>

<p><a href="https://blog.csdn.net/jgdu1981/article/details/6757498">mp3比特池技术</a><br/>
<a href="http://journal2.cqupt.edu.cn/jcuptnse/html/2013/1673-825X-25-4-494.html">功耗高集成度MP3解码器IP核设计</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何获取VideoToolbox的reorder Size]]></title>
    <link href="http://lvpengwei.github.io//blog/2020/03/07/ru-he-huo-qu-videotoolboxde-reorder-size/"/>
    <updated>2020-03-07T11:17:28+08:00</updated>
    <id>http://lvpengwei.github.io//blog/2020/03/07/ru-he-huo-qu-videotoolboxde-reorder-size</id>
    <content type="html"><![CDATA[<h1>Decoder 的区别</h1>

<p>FFmpeg 和 MediaCodec 解码的时候，送数据的顺序是 dts，出数据的顺序是 pts，而 VideoToolbox 是送一个出一个，没有按照 pts 来出数据，需要我们自己排序。</p>

<p>去网上查资料的时候，发现有很多不同的方式</p>

<ol>
<li>sps.max_num_ref_frames</li>
<li>sps.vui.max_num_reorder_frames</li>
<li>通过 sps.level 计算</li>
<li>直接设置为4</li>
</ol>


<p>通过测试几个文件的 sps 发现 <code>max_num_ref_frames</code> 不是很准</p>

<ol>
<li><code>max_num_ref_frames=0; max_num_reorder_frames=2</code></li>
<li><code>max_num_ref_frames=9; max_num_reorder_frames=2</code></li>
</ol>


<h1>sps.max_num_ref_frames</h1>

<p>取 <code>max_num_ref_frames</code> 的有两个播放器，ijkplayer 和 ThumbPlayer</p>

<h2>ijkplayer</h2>

<p>ijkplayer 的逻辑是先取 <code>sps.max_num_ref_frames</code>，然后再取最小值2，最大值5。
```objc
fmt_desc->max_ref_frames = FFMAX(fmt_desc->max_ref_frames, 2);</p>

<p>fmt_desc->max_ref_frames = FFMIN(fmt_desc->max_ref_frames, 5);
```
主要代码在下面两个文件。<br/>
<a href="https://github.com/bilibili/ijkplayer/blob/master/ios/IJKMediaPlayer/IJKMediaPlayer/ijkmedia/ijkplayer/ios/pipeline/IJKVideoToolBoxAsync.m#L1136">IJKVideoToolBoxAsync.m</a><br/>
<a href="https://github.com/bilibili/ijkplayer/blob/cced91e3ae3730f5c63f3605b00d25eafcf5b97b/ios/IJKMediaPlayer/IJKMediaPlayer/ijkmedia/ijkplayer/ios/pipeline/h264_sps_parser.h#L267">h264_sps_parser.h</a></p>

<h2>ThumbPlayer</h2>

<p>ThumbPlayer 的逻辑是取 <code>sps.max_num_ref_frames</code>，如果没有设置为  10。</p>

<h1>sps.vui.max_num_reorder_frames</h1>

<p>取 <code>max_num_reorder_frames</code> 的有三个</p>

<ol>
<li><a href="https://cs.chromium.org/">Chrome</a></li>
<li><a href="https://github.com/videolan/vlc">vlc</a></li>
<li><a href="https://cs.android.com/android/platform/superproject/+/master:external/v4l2_codec2/vda/h264_decoder.cc;l=1042?q=max_num_reorder_frames&amp;ss=android%2Fplatform%2Fsuperproject">MediaCodec</a></li>
</ol>


<h2>Chrome</h2>

<p>Chrome 的主要代码如下，代码文件在<a href="https://cs.chromium.org/chromium/src/media/gpu/mac/vt_video_decode_accelerator_mac.cc?dr=CSs&amp;q=vt_video_decode_accelerator_mac&amp;g=0&amp;l=262">vt_video_decode_accelerator_mac.cc</a> 。</p>

<ol>
<li>先判断 <code>pocType</code>，为 2 直接返回不需要排序</li>
<li>再判断是否有 <code>vuiParameters</code>，取 <code>max_num_reorder_frames</code></li>
<li>然后是特定的 profile，不需要排序</li>
<li>最后返回 <code>max_dpb_frames</code> 的 默认值16
```c
int32_t ComputeReorderWindow(const H264SPS* sps) {
// When |pic_order_cnt_type| == 2, decode order always matches presentation
// order.
// TODO(sandersd): For |pic_order_cnt_type| == 1, analyze the delta cycle to
// find the minimum required reorder window.
if (sps->pic_order_cnt_type == 2)
return 0;</li>
</ol>


<p>  // TODO(sandersd): Compute MaxDpbFrames.
  int32_t max_dpb_frames = 16;</p>

<p>  // See AVC spec section E.2.1 definition of |max_num_reorder_frames|.
  if (sps->vui_parameters_present_flag &amp;&amp; sps->bitstream_restriction_flag) {
    return std::min(sps->max_num_reorder_frames, max_dpb_frames);
  } else if (sps->constraint_set3_flag) {
    if (sps->profile_idc == 44 || sps->profile_idc == 86 ||
        sps->profile_idc == 100 || sps->profile_idc == 110 ||
        sps->profile_idc == 122 || sps->profile_idc == 244) {
      return 0;
    }
  }
  return max_dpb_frames;
}
```</p>

<h2>vlc</h2>

<p>vlc 的逻辑和 chrome 类似，多了一个根据 level 计算 <code>max_dpb_frames</code></p>

<ol>
<li>判断是否有 <code>vuiParameters</code>，取 <code>max_num_reorder_frames</code></li>
<li>然后是特定的 profile，不需要排序</li>
<li>最后计算 <code>max_dpb_frames</code></li>
</ol>


<p>代码文件在<a href="https://github.com/videolan/vlc/blob/d7ff28e96eb2cb64c5b1a502443a24229532a449/modules/packetizer/h264_nal.c#L735">h264_nal.c</a>
```c
static uint8_t h264_get_max_dpb_frames( const h264_sequence_parameter_set_t <em>p_sps )
{
    const h264_level_limits_t </em>limits = h264_get_level_limits( p_sps );
    if( limits )
    {
        unsigned i_frame_height_in_mbs = ( p_sps->pic_height_in_map_units_minus1 + 1 ) *
                                         ( 2 - p_sps->frame_mbs_only_flag );
        unsigned i_den = ( p_sps->pic_width_in_mbs_minus1 + 1 ) * i_frame_height_in_mbs;
        uint8_t i_max_dpb_frames = limits->i_max_dpb_mbs / i_den;
        if( i_max_dpb_frames &lt; 16 )
            return i_max_dpb_frames;
    }
    return 16;
}</p>

<p>bool h264_get_dpb_values( const h264_sequence_parameter_set_t <em>p_sps,
                          uint8_t </em>pi_depth, unsigned <em>pi_delay )
{
    uint8_t i_max_num_reorder_frames = p_sps->vui.i_max_num_reorder_frames;
    if( !p_sps->vui.b_bitstream_restriction_flag )
    {
        switch( p_sps->i_profile ) /</em> E-2.1 <em>/
        {
            case PROFILE_H264_BASELINE:
                i_max_num_reorder_frames = 0; /</em> only I &amp; P <em>/
                break;
            case PROFILE_H264_CAVLC_INTRA:
            case PROFILE_H264_SVC_HIGH:
            case PROFILE_H264_HIGH:
            case PROFILE_H264_HIGH_10:
            case PROFILE_H264_HIGH_422:
            case PROFILE_H264_HIGH_444_PREDICTIVE:
                if( p_sps->i_constraint_set_flags &amp; H264_CONSTRAINT_SET_FLAG(3) )
                {
                    i_max_num_reorder_frames = 0; /</em> all IDR <em>/
                    break;
                }
                /</em> fallthrough */
            default:
                i_max_num_reorder_frames = h264_get_max_dpb_frames( p_sps );
                break;
        }
    }</p>

<pre><code>*pi_depth = i_max_num_reorder_frames;
*pi_delay = 0;

return true;
</code></pre>

<p>}
```</p>

<h2>MediaCodec</h2>

<p><code>MediaCodec</code> 和 <code>vlc</code>/<code>Chrome</code>也差不多，计算<code>max_dpb_frames</code>的时候考虑了<code>max_num_ref_frames</code>和<code>max_dec_frame_buffering</code>
```cpp
bool H264Decoder::ProcessSPS(int sps_id, bool* need_new_buffers) {
  DVLOG(4) &lt;&lt; &ldquo;Processing SPS id:&rdquo; &lt;&lt; sps_id;</p>

<p>  const H264SPS* sps = parser_.GetSPS(sps_id);
  if (!sps)
    return false;</p>

<p>  *need_new_buffers = false;</p>

<p>  if (sps->frame_mbs_only_flag == 0) {
    DVLOG(1) &lt;&lt; &ldquo;frame_mbs_only_flag != 1 not supported&rdquo;;
    return false;
  }</p>

<p>  Size new_pic_size = sps->GetCodedSize().value_or(Size());
  if (new_pic_size.IsEmpty()) {
    DVLOG(1) &lt;&lt; &ldquo;Invalid picture size&rdquo;;
    return false;
  }</p>

<p>  int width_mb = new_pic_size.width() / 16;
  int height_mb = new_pic_size.height() / 16;</p>

<p>  // Verify that the values are not too large before multiplying.
  if (std::numeric_limits<int>::max() / width_mb &lt; height_mb) {
    DVLOG(1) &lt;&lt; &ldquo;Picture size is too big: &rdquo; &lt;&lt; new_pic_size.ToString();
    return false;
  }</p>

<p>  int level = sps->level_idc;
  int max_dpb_mbs = LevelToMaxDpbMbs(level);
  if (max_dpb_mbs == 0)
    return false;</p>

<p>  // MaxDpbFrames from level limits per spec.
  size_t max_dpb_frames = std::min(max_dpb_mbs / (width_mb * height_mb),
                                   static_cast<int>(H264DPB::kDPBMaxSize));
  DVLOG(1) &lt;&lt; &ldquo;MaxDpbFrames: &rdquo; &lt;&lt; max_dpb_frames
           &lt;&lt; &ldquo;, max_num_ref_frames: &rdquo; &lt;&lt; sps->max_num_ref_frames
           &lt;&lt; &ldquo;, max_dec_frame_buffering: &rdquo; &lt;&lt; sps->max_dec_frame_buffering;</p>

<p>  // Set DPB size to at least the level limit, or what the stream requires.
  size_t max_dpb_size =
      std::max(static_cast<int>(max_dpb_frames),
               std::max(sps->max_num_ref_frames, sps->max_dec_frame_buffering));
  // Some non-conforming streams specify more frames are needed than the current
  // level limit. Allow this, but only up to the maximum number of reference
  // frames allowed per spec.
  DVLOG_IF(1, max_dpb_size > max_dpb_frames)
      &lt;&lt; &ldquo;Invalid stream, DPB size > MaxDpbFrames&rdquo;;
  if (max_dpb_size == 0 || max_dpb_size > H264DPB::kDPBMaxSize) {
    DVLOG(1) &lt;&lt; &ldquo;Invalid DPB size: &rdquo; &lt;&lt; max_dpb_size;
    return false;
  }</p>

<p>  if ((pic_size<em> != new_pic_size) || (dpb</em>.max_num_pics() != max_dpb_size)) {
    if (!Flush())
      return false;
    DVLOG(1) &lt;&lt; &ldquo;Codec level: &rdquo; &lt;&lt; level &lt;&lt; &ldquo;, DPB size: &rdquo; &lt;&lt; max_dpb_size
             &lt;&lt; &ldquo;, Picture size: &rdquo; &lt;&lt; new_pic_size.ToString();
    *need_new_buffers = true;
    pic_size<em> = new_pic_size;
    dpb</em>.set_max_num_pics(max_dpb_size);
  }</p>

<p>  Rect new_visible_rect = sps->GetVisibleRect().value_or(Rect());
  if (visible_rect<em> != new_visible_rect) {
    DVLOG(2) &lt;&lt; &ldquo;New visible rect: &rdquo; &lt;&lt; new_visible_rect.ToString();
    visible_rect</em> = new_visible_rect;
  }</p>

<p>  if (!UpdateMaxNumReorderFrames(sps))
    return false;
  DVLOG(1) &lt;&lt; &ldquo;max_num_reorder_frames: &rdquo; &lt;&lt; max_num_reorder_frames_;</p>

<p>  return true;
}</p>

<p>bool H264Decoder::UpdateMaxNumReorderFrames(const H264SPS* sps) {
  if (sps->vui_parameters_present_flag &amp;&amp; sps->bitstream_restriction_flag) {
    max_num_reorder_frames<em> =
        base::checked_cast<size_t>(sps->max_num_reorder_frames);
    if (max_num_reorder_frames</em> > dpb<em>.max_num_pics()) {
      DVLOG(1)
          &lt;&lt; &ldquo;max_num_reorder_frames present, but larger than MaxDpbFrames (&rdquo;
          &lt;&lt; max_num_reorder_frames</em> &lt;&lt; &ldquo; > &rdquo; &lt;&lt; dpb<em>.max_num_pics() &lt;&lt; &ldquo;)&rdquo;;
      max_num_reorder_frames</em> = 0;
      return false;
    }
    return true;
  }</p>

<p>  // max_num_reorder_frames not present, infer from profile/constraints
  // (see VUI semantics in spec).
  if (sps->constraint_set3_flag) {
    switch (sps->profile_idc) {
      case 44:
      case 86:
      case 100:
      case 110:
      case 122:
      case 244:
        max_num_reorder_frames<em> = 0;
        break;
      default:
        max_num_reorder_frames</em> = dpb<em>.max_num_pics();
        break;
    }
  } else {
    max_num_reorder_frames</em> = dpb_.max_num_pics();
  }</p>

<p>  return true;
}
```</p>

<h1>sps.level 计算</h1>

<p><code>vlc</code>和<code>MediaCodec</code> 都计算得出<code>dpb.max_num_pics</code>，拿这个值保底<br/>
<a href="https://github.com/GStreamer/gst-plugins-bad/blob/bc128d610063a266a1b715e5a696ca252f2d5a74/sys/applemedia/vtdec.c#L962">gst-plugins-bad</a> 只通过 level 计算，计算部分和 <code>MediaCodec</code>一样。</p>

<h1>设置为4</h1>

<p><a href="https://juejin.im/post/5d1385c751882532531bca11">iOS解码关于视频中带B帧排序问题</a></p>

<h1>HEVC</h1>

<p>vlc 中还有 <code>HEVC(H265)</code> 视频获取 <code>max_num_reorder</code> 的方式，代码文件在<a href="https://github.com/videolan/vlc/blob/b525b27e85f1f2cec0fe9b38e08f5dee698a893e/modules/packetizer/hevc_nal.c#L1111">hevc_nal.c</a></p>

<h1>FFmpeg</h1>

<p><a href="https://github.com/FFmpeg/FFmpeg/blob/177c68e3496e0d807641110f2a76d25ad71e45bb/libavcodec/h264_slice.c#L1336">h264</a><br/>
<a href="https://github.com/FFmpeg/FFmpeg/blob/177c68e3496e0d807641110f2a76d25ad71e45bb/libavcodec/hevc_refs.c#L174">h265</a></p>

<h1>总结</h1>

<ul>
<li><code>Chrome</code>，<code>vlc</code>，<code>MediaCodec</code>的策略几乎一致，<code>MediaCodec</code>逻辑最完整。</li>
<li><code>vlc</code>还处理了<code>hevc</code>的<code>max_num_reorder</code></li>
</ul>


<h1>Link</h1>

<p><a href="https://github.com/bilibili/ijkplayer/blob/cced91e3ae3730f5c63f3605b00d25eafcf5b97b/ios/IJKMediaPlayer/IJKMediaPlayer/ijkmedia/ijkplayer/ios/pipeline/h264_sps_parser.h#L267">ijkplayer</a><br/>
<a href="https://cs.chromium.org/">Chrome</a><br/>
<a href="https://github.com/videolan/vlc">vlc</a><br/>
<a href="https://cs.android.com/">Android</a><br/>
<a href="https://github.com/FFmpeg/FFmpeg">FFmpeg</a><br/>
<a href="https://juejin.im/post/5d1385c751882532531bca11">iOS解码关于视频中带B帧排序问题</a></p>
]]></content>
  </entry>
  
</feed>
